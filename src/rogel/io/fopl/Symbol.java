package rogel.io.fopl;

import java.util.HashMap;

/**
 * A {@code Symbol} is an object that represents. Everything expressed in FOPL is done in terms of
 * Symbols. In this implementation, Symbols follow the Herbrand interpretation and are merely 
 * objects that represent {@code String}-based names. There is only <b>one</b> Symbol with any
 * given name.
 * <p>
 * The set of all Symbols that are declared during the execution of any FOPL program constitute
 * that program's domain of discourse. 
 * @author recardona
 * @see {@link http://en.wikipedia.org/wiki/Herbrand_interpretation}
 */
public final class Symbol {

	/**
	 * The domain of discourse is the set of entities over which variables of interest in some 
	 * formal language may range. For Symbols, this domain captures every Symbol that has been 
	 * used during program execution.
	 */
	private static HashMap<String, Symbol> symbolDomainOfDiscourse = new HashMap<String, Symbol>();

	/** 
	 * The number to use as a suffix for Symbols generated by the method 
	 * {@code Symbol.generateSymbol()}. 
	 */
	private static int generatedSymbolSuffix = 0;
	
	/** The String name this Symbol represents. */
	private String name;
	
	/**
	 * Returns a Symbol with the given name. If no such Symbol exists, this method creates a new 
	 * one and adds it to the domain of discourse for future retrieval.
	 * @param name the name of the Symbol that is sought.
	 * @return a Symbol with the given name.
	 * @throws IllegalArgumentException if the Symbol name is null or empty.
	 */
	public static Symbol get(String name) throws IllegalArgumentException {
		
		if((name == null) || (name.equals(""))) {
			throw new IllegalArgumentException("Attempted to get a Symbol without a name.");
		}

		if(Symbol.symbolDomainOfDiscourse.containsKey(name)) {
			return symbolDomainOfDiscourse.get(name);
		}
		
		Symbol newSymbol = new Symbol(name);
		Symbol.symbolDomainOfDiscourse.put(name, newSymbol);
		return newSymbol;
	}
	
	/**
	 * Generates a new Symbol within the domain of discourse. The new Symbol is guaranteed to be 
	 * unique, and will be of the form {@code G{number}}, where {@code {number}} is an integer.
	 * @return the newly generated Symbol.
	 */
	public static Symbol generateSymbol() {
		
		// Attempt to create an unused Symbol name.
		String generatedSymbolName = "G" + Symbol.generatedSymbolSuffix;
		
		// If that Symbol already exists, increment the counter and try again.
		while(Symbol.symbolDomainOfDiscourse.containsKey(generatedSymbolName)) {
			Symbol.generatedSymbolSuffix++;
			generatedSymbolName = "G" + Symbol.generatedSymbolSuffix;
		}
		
		// Return the new Symbol.
		return Symbol.get(generatedSymbolName);
	}
	
	/**
	 * Generates a new Symbol within the domain of discourse. The new Symbol is guaranteed to be
	 * unique, and will be of the form {@code {prefix}{number}}, where {@code {prefix}} is the 
	 * parameter String, and {@code {number}} is an integer.
	 * @param prefix the prefix of the Symbol to generate.
	 * @return the newly generated Symbol.
	 */
	public static Symbol generateSymbol(String prefix) {
		
		// Attempt to create an unused Symbol name.
		String generatedSymbolName = prefix + Symbol.generatedSymbolSuffix;
		
		// If that Symbol already exists, increment the counter and try again.
		while(Symbol.symbolDomainOfDiscourse.containsKey(generatedSymbolName)) {
			Symbol.generatedSymbolSuffix++;
			generatedSymbolName = prefix + Symbol.generatedSymbolSuffix;
		}
		
		// Return the new Symbol.
		return Symbol.get(generatedSymbolName);
	}
	
	/**
	 * Constructs a Symbol of the given name.
	 * @param name the name of the symbol.
	 */
	private Symbol(String name) {
		this.name = name;
	}
	
	/*
	 * (non-Javadoc)
	 * @see java.lang.Object#clone()
	 */
	@Override
	protected Object clone() throws CloneNotSupportedException {
		throw new CloneNotSupportedException("Symbol.clone() is not supported");
	}
	
	/**
	 * Returns a {@code String} representation of this Symbol, which is simply the name that this
	 * object represents.
	 */
	@Override
	public String toString() {
		return this.name;
	}
	
	/**
	 * Compares this Symbol to the parameter object. The result is {@code true} if and only if the
	 * argument is another {@code Symbol} whose name is syntactically equivalent (i.e. represents 
	 * the same sequence of characters) as this object.
	 * @param obj The object to compare this {@code Symbol} against.
	 * @return {@code true} if the given object represents a {@code Symbol} whose name is syntactically
	 * 	equivalent to this Symbol's name, {@code false} otherwise.
	 */
	@Override
	public boolean equals(Object obj) {
		if( ! (obj instanceof Symbol)) {
			return false;
		}
		
		Symbol other = (Symbol) obj;
		return (this.name.equals(other.name));
	}
	
	/**
	 * Returns a hash code for this Symbol. The hash code for a {@code Symbol} object is computed
	 * as the hash of the sequence of characters the Symbol represents; i.e. 
	 * {@code this.toString().hashCode()}.
	 * @return a hash code value for this object.
	 */
	@Override
	public int hashCode() {
		return this.name.hashCode();
	}
}
